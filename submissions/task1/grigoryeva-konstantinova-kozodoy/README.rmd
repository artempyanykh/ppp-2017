---
title: "README"
author: "Konstantinova Grigorieva Kozodoi"
date: '9 апреля 2017 г '
output: html_document
---

#Цель задания 

В первом задании практикума необходимо было провести анализ некоторого временного ряда и попробовать предсказать значения для последующих месяцев.
Нашей задачей является анализ временного ряда и оценка полученных результатов с помощью R.

#Выполнение задания
В первую очередь подключаем необходмые для работы билиотеки: 

```{r,echo=FALSE}
install.packages("forecast")
install.packages("MLmetrics")
install.packages("tseries")
install.packages("zoo")
install.packages("xts")
library(forecast)
library(MLmetrics)
library(tseries)
library(zoo)
library(xts)
```

###Были выполнены три части задания: 
1. Считать данные из training.csv. Ответы на тестовой выборке testing.csv использовать в финальном эксперементе. 
Проверить является ли ряд стационарным в широком смысле. 
Начальная проверка проводится с помощью теста Дики-Фуллера: используем функцию adf.test и гипотезу, что при наличии единичного корня ряд можно считать нестационарным.
Далее строим скользящие статистики - скользящее среднее с помощью rollmean и стандартное отклонение по формуле (((X1(среднее) - X(исходный ряд))^2)/360)^1/2. Строим их графики красным и синим соответственно. 
Проводим визуальную оценку и убеждаемся в нестационарности ряда. 
По результатам двух тестов можем быть уверены в нестационарности исходного ряда.

```{r,echo=FALSE}
times_series<-read.csv("training.csv",header=TRUE, row.names = 1)
times_series.ts<-ts(times_series, start=c(1959,1), frequency=12)
times_series.ts
plot.ts(times_series.ts)

adf.test(times_series.ts,alternative="stationary")

times_series_rm<-rollmean(times_series.ts,4)
lines(times_series_rm,col="red")

times_series_sd<-((times_series_rm-times_series.ts)^2/359)^(1/2)
lines(times_series_sd+40,col="blue")
```

2. Разложить временной ряд на тренд, сезональность, остаток в соответствии с аддитивной, мультипликативной моделями. Мы делаем это с помощью функции decompose, меняя тип ("additive" и "multiplicative"). Визуализируем и оцениваем стационарность рядов. Получаем: тренд - не стационарен, сезональность и остаток - стационарны.
Первый график - временной ряд
Второй график - оценка составляющей тренда
Третий график - оценка сезонной компоненты
Четвертый график - оценка случайной компоненты

```{r,echo=FALSE}
type<-c("additive", "multiplicative")
times_series_components<-decompose(times_series.ts,type[1])
plot(times_series_components)
times_series_components<-decompose(times_series.ts,type[2])
plot(times_series_components)

adf.test(times_series_components$seasonal,alternative="stationary")
times_series_components$trend
times_series_components$random
```

3. Проверить является ли временной ряд интегрированным и в случае интегрируемости найти его порядок. Проверяем, является ли временной ряд интегрированным. Вычисляем первые разности ряда с помощью функции diff. Проверяем полученный ряд на стационарность. Так как он стационарен, то исходный ряд является интегрированным. Используем функцию ndiffs, чтобы посчитать порядок интегрирования.
Далее вычисляем параметры для построения моделей ARIMA. 
Вычисляем параметр p: С помощью функции pacf (частичная автокорреляция) от полученного после использования функции diff стационарного ряда находим первый лаг, значение которого попадает в границы значимости, берем предыдущий от него номер (нумерация лагов начинается с 1) и получаем таким образом p. 
Вычисляем параметр d: Он равен порядку интегрированного ряда.
Вычисляем параметр q: С помощью функции acf(автокорреляция) от полученного после использывания функции diff стационарного ряда находим первый лаг, значение которого попадает в границы значимости, берем предыдущий от него номер (нумерация лагов начинается с 0) и получаем таким образом q. 

```{r,echo=FALSE}
diff_1<-diff(times_series.ts, differences=1)
plot.ts(diff_1)
adf.test(diff_1,alternative="stationary")
d<-ndiffs(times_series.ts)
(acf(diff_1,main=""))
(pacf(diff_1,main=""))
```

Строим несколько моделей ARIMA с параметрами, выбранными таким образом, что: 0<=p<=2, d=1, 0<=q<=4. 
Вычисляем для каждой модели прогноз с помощью forecast.Arima. Проверяем, что для каждого прогноза значение r2_score(коэффицент детерминации) достаточно близко к нулю, что является хорошим результатом. Визуализируем forecast.Arima для всех моделей. 
С помощью информационного критерия Акаике(AIC) из всех этих моделей находим наилучшую: выбираем модель с минимальным значением критерия AIC. 
Визуализируем forecast.Arima выбранной модели и получаем область прогноза дальнейших значений временного ряда. Далее считываем файл testing.csv и строим его график.
График лежит внутри спрогнозируемой области, значит прогноз верен.
Но в силу того, что показатель r2-score для моделей с наилучшим образом подобранными параметрами отрицательный, прогнозирование на 60 месяцев вперед с использованием модели ARIMA является плохим решением задачи. Также 60 месяцев, предоставленные к прогнозу по заданию, не являются подходящим периодом для прогнозирования в данном случае.

```{r,echo=FALSE}

model01<-arima(times_series.ts,order=c(2,1,0))
model02<-arima(times_series.ts,order=c(0,1,4))
model03<-arima(times_series.ts,order=c(2,1,4))
model04<-arima(times_series.ts,order=c(1,1,1))


frts_1<-forecast.Arima(model01,h=60)
R2_Score(frts_1$mean,test.ts)
plot.forecast(frts_1)
frts_2<-forecast.Arima(model02,h=60)
R2_Score(frts_2$mean,test.ts)
plot.forecast(frts_2)
frts_3<-forecast.Arima(model03,h=60)
R2_Score(frts_3$mean,test.ts)
plot.forecast(frts_3)
frts_4<-forecast.Arima(model04,h=60)
R2_Score(frts_4$mean,test.ts)
plot.forecast(frts_4)

AIC(model01,model02,model03,model04)

plot.forecast(frts_2)
test<-read.csv("testing.csv",header=TRUE, row.names = 1)
test.ts<-ts(test, start=c(1989,1), frequency=12)
test.ts
lines(test.ts,col='red')
frts_2$mean
```
#Задание выполняли студенты 412 группы:
Григорьева Олеся - Написание кода и всех результатов в Github.
Константинова Мария - Написание кода и отчета.
Козодой Антон - Написание отчета. 

