#+TITLE: Отчет по Заданию 1
#+AUTHOR: Михаил Масло
#+LATEX_HEADER: \usepackage[T2A]{fontenc}
#+LATEX_HEADER: \usepackage[english, russian]{babel}
#+LANGUAGE: ru
#+OPTIONS: ':t toc:2

* Какие библиотеки использовались?
При исследовании временных рядов было использовано три библиотеки ~TTR~, ~tseries~, ~forecast~
При отсутсвии данных пакетов требуется ввести в консоль ввода / вывода ~install.packages("packageName")~

* Считывание данных
Данные считываются следующим образом
~timeSeries = read.csv(file="training.csv", header = TRUE,sep=",")~
Полный путь к файлу указывать необязательно. При запуске команды из командной строки файл будет искать в дириктории файла. При работе в R Studio необходимо перейти во вкладку ~Session~ > ~Set Working Directory~ > ~To Source File Location~. После чего файл будет искаться в дириктории файла

* Визуализация данных на графике
~plot(,)~ - первый агрумент x, второй y. Для выделения цветом используется параметр ~col = "colorName"~ (например, blue, green, red and etc). Для добавления функции в существующих график используется функция ~line(,)~, для которой параметры, которые нас интересуют такие же

* Сохранение результатов
~jpeg()~ - вызывается до ~plot()~
~dev.off()~ - вызывается после того, как все функции были отрисованы на графике - сохраняет файл в формате .jpeg (так как до этого была вызваная функция ~jpeg()~)


* Первый пункт задания
Исследование временного ряда проводилось визуальным образом. Было построено три различных скользящих средних: ~WMA~, ~SMA~, ~EMA~. Визуальные результаты находятся в initial.jpeg. Все скользящие статистики были взяты с параметром n = 20 (порядок). Были использованы
- ~SMA~ - зеленный маркер
- ~WMA~ - красный маркер
- ~EMA~ - синий маркер
- Черным цветом изображен оригинальный временной ряд

* Второй пункт задания
Полученный временной ряд не периодичен, поэтому требуется воспользоваться каким-то приемом, который привел бы ряд к нужному нам виду. В данном случае log() - взятие натурального логарифма.
Функция ~decompose()~ - раскладывает ряд на сезонность, тренд и остаток. У данной функции есть параметр type, за счет которого можно использовать аддитивную / мультипликативную модель (пример: ~type = c("additive")~)
Результаты этого пункта отображены в файлах miltModel.jpeg и additiveModel.jpeg
Далее, надо исследовать сезонную и остаточную часть обеих моделей. Для этого вопспользуемся тестом Дики - Фулера для соответсующих частей получились следующие результаты
```
Augmented Dickey-Fuller Test

data:  addModel$seasonal
Dickey-Fuller = -36.075, Lag order = 7, p-value = 0.01
alternative hypothesis: stationary

Augmented Dickey-Fuller Test

data:  addModel$random
Dickey-Fuller = -7.3136, Lag order = 7, p-value = 0.01
alternative hypothesis: stationary

Augmented Dickey-Fuller Test

data:  multModel$seasonal
Dickey-Fuller = -36.075, Lag order = 7, p-value = 0.01
alternative hypothesis: stationary

Augmented Dickey-Fuller Test

data:  multModel$random
Dickey-Fuller = -7.3136, Lag order = 7, p-value = 0.01
alternative hypothesis: stationary
```

Что может говорить о станционарности полученных рядов, так как p-value < 0.01

Для теста Дики - Фулера была использована функция
~adf.test(*, alternative="stationary")~, где * - исследуемый объект

* Третий пункт задания
Для проверки интегрируемости k - ого порядка необзодимо взять разность последовательных элементов ряда (функция diff) k раз. И исследовать получившийся ряд на сходимость. При исследовании ряда было найдено, что при k = 1 ряд станционарен. Полученные результаты есть в файле diff1.jpeg

Далее вычислим функцию автокорреляции и функции частичной автокорреляции, в языке R есть две соответсвующих функциии
~acf <- acf(x = dif,plot = TRUE)
pacf <- pacf(x = dif, plot = TRUE)~
Второй параметр так же строит график получившейся функции (аналогично ~plot()~)
Результаты графиков можно найти в acf.jpeg и pacf.jpeg

Рассмотри оба из них и возьмем количество параметров которые сильно отличаются от 0. Получается p = 3, q = 8
~trainSer <- ts(value, frequency = 12, start = c(1959))
arima <- arima(trainSer, order = c(1, 3, 8))~
~value~ - оригинальные значения временного ряда
Посмотрим на сколько хорошо эта модель предсказывает значения на тестовых данных, для этого считаем тестовые данные и зададим полученные данные в виде временного ряда
~testSeries = read.csv(file="testing.csv", header = TRUE,sep=",")
testSer <- ts(testSeries$Value, frequency = 12, start = c(1989))~
Далее, сделаем прогноз и выведем прогноз с тестовыми данными на один график
~aForecast = forecast.Arima(arima, h = 60)
plot(aForecast)
lines(testSer, col = "green")~

Проведем тест при помозь информационного критерия Акаике и r2_score
~M.lm <- lm(aForecast$mean~testSer)
str(summary(M.lm))
AIC(arima)~

Получим:
~r.squared    : num 0.631~ - ~r2_score~
~[1] 297.8515~ - ~AIC~
~AIC~ - информационный критерий Акаике

Постараемся уменьшить параметр, q, потому как изменение параметра p не приводит к видимым изменениям. Возьмем p = 4, тогда для такой модели аналогичные результаты будут следующими:
r.squared    : num 0.586
~[1] 311.6136~
~r2 score~ у второй модели меньше, однако критерий Акаике дает больше, поэтому, можно сделать вывод, что вторая модель делает прогноз лучше первой
