---
title: "Task 1"
author: "Oleg Chaban"
output: 
    html_document: default
    
---

```{r setup, include = FALSE}
library(xts)
library(zoo)
library(tseries)
library(forecast)
library(MLmetrics)
```

# 1 этап
Считываем данных из training.csv.

```{r read}
dates_rows<-read.csv("training.csv", header = TRUE, row.names = 1)
dates_rows.ts<-ts(dates_rows, start=c(1959,1), frequency=12)
```

Построим скользящие статистики - скользящее среднее и стандартное отклонение.

```{r slide}
dates_rows_rl<-rollmean(dates_rows.ts, 5)
dates_rows_d<-((dates_rows_rl-dates_rows.ts)^2/359)^(1/2)
```

Строим график, на котором отрисованны сам ряд и его скользящие статистики. Скользящее среднее окрашено оранжевым цветом, стандартное отклонение - зеленым.

```{r, echo=FALSE}
plot.ts(dates_rows.ts)
lines(dates_rows_rl, col="orange")
lines(dates_rows_d + 45, col="green")
```

Изучив данные графики, можно сказать, что что ряд является нестационарным.

Проведем тест Дики-Фуллера.

```{r adf}
adf.test(dates_rows.ts)
```

Так как корень один, то можно считать, что ряд нестационарен.
В результате, после проведения двух тестов, можно сказать, что исходный ряд является нестационарным.

# 2 этап

Расскладываем временной ряд на тренд, сезональность, остаток в соответствии с аддитивной, мультипликативной моделями.

```{r ssn}
dates_rows_add<-decompose(dates_rows.ts,type = "additive")
dates_rows_mul<-decompose(dates_rows.ts,type = "multiplicative")
```

Построим графики.

```{r, echo=FALSE}
plot(dates_rows_add)
plot(dates_rows_mul)
```

В обеих моделях видно, что тренд не стационарен, но сезональность и остаток - стационарны в широком смысле, т.к. статистические характеристики не изменяются с течением времени. Чтобы удостовериться в этом, проведем тест Дики-Фуллера.

```{r adf1, warning=FALSE}
adf.test(na.remove(dates_rows_add$seasonal), k = 0)
adf.test(na.remove(dates_rows_add$trend), k = 0)
adf.test(na.remove(dates_rows_add$random), k = 0)
adf.test(na.remove(dates_rows_mul$seasonal), k = 0)
adf.test(na.remove(dates_rows_mul$trend), k = 0)
adf.test(na.remove(dates_rows_mul$random), k = 0)
```

Наше предположение верно. В обеих моделях значение параметра p-value у тренда большое, следовательно, ряд не является стационарным. А для остатка и сезональности он мал, что подтверждает их стационарность.

# 3 этап

Проанализируем последовательно разности временного ряда, для того, чтобы определить порядок интегрированности этого ряда.

```{r diff}
diff_n<-diff(dates_rows.ts, differences=1)
plot.ts(diff_n)
```

```{r adf2, warning=FALSE}
adf.test(diff_n, k = 0)
```

Из результатов теста Дики-Фуллера можно сделать вывод, что порядок интегрированности равен 1, т.к. первая разность исходного ряда - стационарна.

Построим функции автокоррелеации и частичной автокоррелеации
```{r acf}
acf(diff_n,main="Автокоррелеация")
pacf(diff_n,main="Частичная автокоррелеация")
```

С помощью pacf и acf находим параметры p и q для построения моделей ARIMA. Параметр d равен порядку интегрированного ряда. Потроим несколько моделей ARIMA с параметрами, выбранными таким образом, что: 0<=p<=2, d=1, 0<=q<=4.

```{r arima}
model01<-Arima(dates_rows.ts,order=c(2,1,0))
model02<-Arima(dates_rows.ts,order=c(0,1,4))
model03<-Arima(dates_rows.ts,order=c(2,1,4))
model04<-Arima(dates_rows.ts,order=c(1,1,1))
```

Считываем данные из testing.csv.

```{r read_test}
test<-read.csv("testing.csv",header=TRUE, row.names = 1)
test.ts<-ts(test, start=c(1989,1), frequency=12)
```

Вычисляем для каждой модели прогноз с помощью forecast.Arima.Так же проверяем, что для каждого прогноза значение r2_score достаточно близко к нулю. Визуализируем forecast.Arima для всех моделей.

```{r f_arima1}
frcst_1<-forecast.Arima(model01,h=60)
R2_Score(frcst_1$mean,test.ts)
plot.forecast(frcst_1)
```

```{r f_arima2}
frcst_2<-forecast.Arima(model02,h=60)
R2_Score(frcst_2$mean,test.ts)
plot.forecast(frcst_2)
```

```{r f_arima3}
frcst_3<-forecast.Arima(model03,h=60)
R2_Score(frcst_3$mean,test.ts)
plot.forecast(frcst_3)
```

```{r f_arima4}
frcst_4<-forecast.Arima(model04,h=60)
R2_Score(frcst_4$mean,test.ts)
plot.forecast(frcst_4)
```

С помощью информационного критерия Акаике(AIC) из всех этих моделей находим наилучшую: выбираем модель с минимальным значением критерия AIC. 

```{r aic}
AIC(model01,model02,model03,model04)
```

Визуализируем forecast.Arima выбранной модели и получаем область прогноза дальнейших значений временного ряда. Строим график тестовой выборки. 

```{r fnl}
plot.forecast(frcst_2)
lines(test.ts,col='green')
```

Мы убедиись, что график лежит внутри спрогнозируемой области. 
Получается, что нами был построен верный прогноз.